class t{constructor(t,s){this.lowerBound=t,this.upperBound=s}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const s=this.lowerBound,i=this.upperBound,e=t.lowerBound,n=t.upperBound,h=e.x<=i.x&&i.x<=n.x||s.x<=n.x&&n.x<=i.x,r=e.y<=i.y&&i.y<=n.y||s.y<=n.y&&n.y<=i.y,o=e.z<=i.z&&i.z<=n.z||s.z<=n.z&&n.z<=i.z;return h&&r&&o}contains(t){const s=this.lowerBound,i=this.upperBound,e=t.lowerBound,n=t.upperBound;return s.x<=e.x&&i.x>=n.x&&s.y<=e.y&&i.y>=n.y&&s.z<=e.z&&i.z>=n.z}clone(){return new t(this.lowerBound.clone(),this.upperBound.clone())}}const s={Box:1,Sphere:2,Plane:4,Cylinder:8,ConvexPolygon:16,Trimesh:32};class i{constructor({type:s}){this.type=s,this.parameters={},this.AABB=new t(new n,new n)}updateBoundingSphereRadius(){throw new Error("Not implemented")}updateAABB(){throw new Error("Not implemented")}calculateInertia(t){throw new Error("Not Implemented")}}class e{constructor(t=0,s=0,i=0,e=1){this.isQuaternion=!0,this.x=t,this.y=s,this.z=i,this.w=e}set(t,s,i,e){return this.x=t,this.y=s,this.z=i,this.w=e,this}clone(){return new e(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}setFromAxisAngle(t,s){const i=s/2,e=Math.sin(i);return this.x=t.x*e,this.y=t.y*e,this.z=t.z*e,this.w=Math.cos(i),this}setFromVectors(t,s){let i=t.dot(s)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this.x=-t.y,this.y=t.x,this.z=0,this.w=i):(this.x=0,this.y=-t.z,this.z=t.y,this.w=i)):(this.x=t.y*s.z-t.z*s.y,this.y=t.z*s.x-t.x*s.z,this.z=t.x*s.y-t.y*s.x,this.w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs((s=this.dot(t),i=-1,e=1,Math.max(i,Math.min(e,s)))));var s,i,e}rotateTowards(t,s){const i=this.angleTo(t);if(1===s)return this.copy(t);if(0===i)return this;const e=Math.min(1,s/i);return this.slerp(t,e),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}normalize(){let t=this.length();return 0===t?(this.x=0,this.y=0,this.z=0,this.w=1):(t=1/t,this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this.w=this.w*t),this}multiply(t){return this.mulQuaternion(t)}mulQuaternion(t){const s=this.x,i=this.y,e=this.z,n=this.w,h=t.x,r=t.y,o=t.z,a=t.w;return this.x=s*a+n*h+i*o-e*r,this.y=i*a+n*r+e*h-s*o,this.z=e*a+n*o+s*r-i*h,this.w=n*a-s*h-i*r-e*o,this.normalize(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const i=this.x,e=this.y,n=this.z,h=this.w;let r=h*t.w+i*t.x+e*t.y+n*t.z;if(r<0?(this.w=-t.w,this.x=-t.x,this.y=-t.y,this.z=-t.z,r=-r):this.copy(t),r>=1)return this.w=h,this.x=i,this.y=e,this.z=n,this;const o=1-r*r;if(o<=Number.EPSILON){const t=1-s;return this._w=t*h+s*this.w,this._x=t*i+s*this.x,this._y=t*e+s*this.y,this._z=t*n+s*this.z,this.normalize(),this}const a=Math.sqrt(o),u=Math.atan2(a,r),l=Math.sin((1-s)*u)/a,c=Math.sin(s*u)/a;return this._w=h*l+this._w*c,this._x=i*l+this._x*c,this._y=e*l+this._y*c,this._z=n*l+this._z*c,this}random(){const t=Math.random(),s=Math.sqrt(1-t),i=Math.sqrt(t),e=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(s*Math.cos(e),i*Math.sin(n),i*Math.cos(n),s*Math.sin(e))}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}class n{constructor(t,s,i){this.isVector=!0,this.x=t??0,this.y=s??0,this.z=i??0}add(t,s,i){return t instanceof Object?(this.x+=t.x,this.y+=t.y,this.z+=t.z):(this.x+=t,this.y+=s??0,this.z+=i??0),this}sub(t,s,i){return t instanceof Object?(this.x-=t.x,this.y-=t.y,this.z-=t.z):(this.x-=t,this.y-=s??0,this.z-=i??0),this}mul(t,s,i){return t instanceof Object?(this.x*=t.x,this.y*=t.y,this.z*=t.z):null==s?(this.x*=t,this.y*=t,this.z*=t):(this.x*=t,this.y*=s??0,this.z*=i??0),this}div(t,s,i){return t instanceof Object?(this.x/=t.x,this.y/=t.y,this.z/=t.z):null==s?(this.x/=t,this.y/=t,this.z/=t):(this.x/=t,this.y/=s??0,this.z/=i??0),this}added(t,s,i){return t instanceof Object?new n(this.x+t.x,this.y+t.y,this.z+t.z):null==s?new n(this.x+t,this.y+t,this.z+t):new n(this.x+t,this.y+(s??0),this.z+(i??0))}subed(t,s,i){return t instanceof Object?new n(this.x-t.x,this.y-t.y,this.z-t.z):null==s?new n(this.x-t,this.y-t,this.z-t):new n(this.x-t,this.y-(s??0),this.z-(i??0))}muled(t,s,i){return t instanceof Object?new n(this.x*t.x,this.y*t.y,this.z*t.z):null==s?new n(this.x*t,this.y*t,this.z*t):new n(this.x*t,this.y*(s??0),this.z*(i??0))}dived(t,s,i){return t instanceof Object?new n(this.x/t.x,this.y/t.y,this.z/t.z):null==s?new n(this.x/t,this.y/t,this.z/t):new n(this.x/t,this.y/(s??0),this.z/(i??0))}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}negated(){return new n(-this.x,-this.y,-this.z)}mulScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}muledScalar(t){return new n(this.x*t,this.y*t,this.z*t)}divScalar(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,s){const i=this.x+(t.x-this.x)*s,e=this.y+(t.y-this.y)*s,h=this.z+(t.z-this.z)*s;return new n(i,e,h)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return this.x=this.y*t.z-this.z*t.y,this.y=this.z*t.x-this.x*t.z,this.z=this.x*t.y-this.y*t.x,this}crossed(t){return new n(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}normalize(t=1){const s=this.length()*t;return this.x/=s,this.y/=s,this.z/=s,this}normalized(t=1){const s=this.length()*t;return new n(this.x/s,this.y/s,this.z/s)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}applyQuaternion(t){const s=this.x,i=this.y,e=this.z,n=t.x,h=t.y,r=t.z,o=t.w,a=2*(h*e-r*i),u=2*(r*s-n*e),l=2*(n*i-h*s);return this.x=s+o*a+h*l-r*u,this.y=i+o*u+r*a-n*l,this.z=e+o*l+n*u-h*a,this}distanceTo(t){return Math.sqrt((t.x-this.x)*(t.x-this.x)+(t.y-this.y)*(t.y-this.y)+(t.z-this.z)*(t.z-this.z))}distanceToSq(t){return(t.x-this.x)*(t.x-this.x)+(t.y-this.y)*(t.y-this.y)+(t.z-this.z)*(t.z-this.z)}toArray(){return[this.x,this.y,this.z]}clone(){return new n(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}set(t,s,i){this.x=t,this.y=s,this.z=i}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}}class h{constructor(t,s){this.vertices=t,this.normal=void 0!==s?s:function(t){const s=new n;for(let i=0;i<t.length;i++){const e=t[i],n=t[(i+1)%t.length];s.add((e.y-n.y)*(e.z+n.z),(e.z-n.z)*(e.x+n.x),(e.z-n.z)*(e.y+n.y))}return s.normalize()}(t)}}class r extends i{constructor({type:t=s.ConvexPolygon,vertices:i,faces:e,axes:n}){super({type:t}),this.type=t,this.vertices=i,this.faces=e,this.axes=n,this.needVerticesUpdate=!1}getFurthestVertex(){let t,s=-1/0;for(const i of this.vertices){const e=i.length();e>s&&(s=e,t=i)}if(void 0===t)throw new Error("This ConvexPolygons does not contain any vertex");return t.clone()}getNearestVertex(){let t,s=1/0;for(const i of this.vertices){const e=i.length();e<s&&(s=e,t=i)}if(void 0===t)throw new Error("This ConvexPolygons does not contain any vertex");return t.clone()}getFurthestVertexInDirection(t){let s,i=-1/0;for(const e of this.vertices){const n=e.dot(t);n>i&&(i=n,s=e)}if(void 0===s)throw new Error("This ConvexPolygon does not contain any vertex");return s.clone()}updateBoundingSphereRadius(){this.boundingSphereRadius=this.getFurthestVertex().length()}updateAABB(){let s=1/0,i=1/0,e=1/0,h=-1/0,r=-1/0,o=-1/0;for(const t of this.vertices)t.x<s?s=t.x:t.x>h&&(h=t.x),t.y<i?i=t.y:t.y>r&&(r=t.y),t.z<e?e=t.z:t.z>o&&(o=t.z);this.AABB=new t(new n(s,i,e),new n(h,r,o))}}class o extends r{constructor(t,i,e){let r,o,a;t instanceof n?(r=t.x,o=t.y,a=t.z):null==i?(r=t,o=t,a=t):(r=t,o=i,a=e??0);const{vertices:u,faces:l,axes:c}=function(t,s,i){const e=[new n(-t,-s,-i),new n(t,-s,-i),new n(t,s,-i),new n(-t,s,-i),new n(-t,-s,i),new n(t,-s,i),new n(t,s,i),new n(-t,s,i)];return{vertices:e,faces:[new h([e[3],e[2],e[1],e[0]],new n(0,0,-1)),new h([e[4],e[5],e[6],e[7]],new n(0,0,1)),new h([e[5],e[4],e[0],e[1]],new n(0,-1,0)),new h([e[2],e[3],e[7],e[6]],new n(0,1,0)),new h([e[0],e[4],e[7],e[3]],new n(-1,0,0)),new h([e[1],e[2],e[6],e[5]],new n(1,0,0))],axes:[new n(0,0,1),new n(0,1,0),new n(1,0,0)]}}(r/2,o/2,a/2);super({type:s.Box,vertices:u,faces:l,axes:c}),this.parameters={width:r,height:o,depth:a},this.updateBoundingSphereRadius(),this.updateAABB()}updateBoundingSphereRadius(){this.boundingSphereRadius=Math.sqrt(this.parameters.width*this.parameters.width+this.parameters.height*this.parameters.height+this.parameters.depth*this.parameters.depth)}updateAABB(){this.AABB=new t(new n(-this.parameters.width/2,-this.parameters.height/2,-this.parameters.depth/2),new n(this.parameters.width/2,this.parameters.height/2,this.parameters.depth/2))}calculateInertia(t){const s=this.parameters.width,i=this.parameters.height,e=this.parameters.depth;return new n(1/(12*t*(2*s*2*i+2*e*2*e)),1/(12*t*(2*s*2*s+2*e*2*e)),1/(12*t*(2*i*2*i+2*s*2*s)))}}class a extends i{constructor(t=0){super({type:s.Sphere}),this.params={radius:t},this.radius=t,this.updateBoundingSphereRadius(),this.updateAABB()}updateAABB(){const s=new n(1,0,0).normalize().mulScalar(this.radius);this.AABB=new t(s.negated(),s)}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateInertia(t){const s=.4*t*this.radius*this.radius;return new n(s,s,s)}}class u{constructor({points:t,normal:s,penetration:i}){this.points=t,this.normal=s,this.penetration=i}}const l={resolve(t,s,i){this.penetrationResolution(t,s,i),this.applyImpulse(t,s,i)},penetrationResolution(t,s,i){const e=i.normal.muledScalar(i.penetration),n=t.mass+s.mass;t.position.add(e.muledScalar(-t.mass/n)),s.position.add(e.muledScalar(s.mass/n))},applyImpulse(t,s,i){const e=[];for(const n of i.points){const h=i.normal,r=n.subed(t.position),o=n.subed(s.position),a=t.material.restitution*s.material.restitution,u=t.velocity.sub(s.velocity).dot(h)*-(1+a)/(t.invMass+s.invMass);e.push({impulse:u/i.points.length,normal:h,ra:r,rb:o})}for(const i of e){const e=i.normal.mul(i.impulse);t.applyImpulse(e,i.ra),s.applyImpulse(e.negated(),i.rb)}}};class c{constructor(t=1,s=0,i=0,e=0,n=1,h=0,r=0,o=0,a=1){this.elements=[t,s,i,e,n,h,r,o,a]}get(t,s){return this.elements[3*t+s]}set(t,s,i){this.elements[3*t+s]=i}mul(t){const s=new c;for(let i=0;i<3;i++)for(let e=0;e<3;e++){let n=0;for(let s=0;s<3;s++)n+=this.get(i,s)*t.get(s,e);s.set(i,e,n)}return s}mulScalar(t){const s=new c;for(let i=0;i<9;i++)s.elements[i]=this.elements[i]*t;return s}}class d{addEventListener(t,s){void 0===this.listeners&&(this.listeners=new Map);let i=this.listeners.get(t);void 0===i&&(i=[],this.listeners.set(t,i)),-1===i.indexOf(s)&&i.push(s)}hasEventListener(t,s){if(void 0===this.listeners)return!1;const i=this.listeners.get(t);return void 0!==i&&(-1===i.indexOf(s)&&void 0)}removeEventListener(t,s){if(void 0===this.listeners)return;const i=this.listeners.get(t);if(void 0!==i){const t=i.indexOf(s);-1!==t&&i.splice(t,1)}}dispatchEvent(t){if(void 0===this.listeners)return;const s=this.listeners.get(t.type);if(void 0!==s){t.target=this;const i=s.slice(0);for(let s=0,e=i.length;s<e;s++)i[s].call(this,t);t.target=null}}}class p{constructor(t,s={}){this.type=t,this.params=s,this.target}}const y=0;class x extends d{constructor({shape:s,mass:i=0,material:h=new v({restitution:.1})}){super(),this.shape=s,this.type=y,this.name="UnamedObject",this.material=h,this.position=new n,this.velocity=new n,this.quaternion=new e,this.angularVelocity=new n,this.mass=i,this.invMass,this.inertia=this.shape.calculateInertia(this.mass),this.invInertia=new n,this.inertiaScalar,this.invInertiaScalar,this.updateMass(),this.AABB=new t(new n,new n),this.updateAABB(),this.parrent=null,this.worldInfo={AABB:new t(this.AABB.lowerBound.clone().add(this.position),this.AABB.upperBound.clone().add(this.position))},this.previousInfo={position:this.position.clone(),quaternion:this.quaternion.clone(),mass:i}}update(t,s){if(0!==this.mass&&this.position.add(this.velocity.muledScalar(s)),!this.angularVelocity.isZero()){const t=(new e).setFromAxisAngle(this.angularVelocity.normalized(),this.angularVelocity.length()*s);this.quaternion.mulQuaternion(t)}this.position.equals(this.previousInfo.position)||(this.updateWorldPositionAABB(),this.previousInfo.position.copy(this.position)),this.quaternion.equals(this.previousInfo.quaternion)||(this.updateWorldRotationAABB(),this.previousInfo.quaternion.copy(this.quaternion)),this.mass!=this.previousInfo.mass&&(this.previousInfo.mass=this.mass,this.updateMass())}updateWorldPositionAABB(){this.worldInfo.AABB=new t(this.AABB.lowerBound.added(this.position),this.AABB.upperBound.added(this.position))}updateWorldRotationAABB(){const s=new n(1/0,1/0,1/0),i=new n(-1/0,-1/0,-1/0);if(this.shape instanceof r)for(const t of this.shape.vertices){const e=t.clone().applyQuaternion(this.quaternion);e.x<s.x&&(s.x=e.x),e.y<s.y&&(s.y=e.y),e.z<s.z&&(s.z=e.z),e.x>i.x&&(i.x=e.x),e.y>i.y&&(i.y=e.y),e.z>i.z&&(i.z=e.z)}this.shape instanceof a&&(-this.shape.radius<s.x&&(s.x=-this.shape.radius),-this.shape.radius<s.y&&(s.y=-this.shape.radius),-this.shape.radius<s.z&&(s.z=-this.shape.radius),this.shape.radius>i.x&&(i.x=this.shape.radius),this.shape.radius>i.y&&(i.y=this.shape.radius),this.shape.radius>i.z&&(i.z=this.shape.radius)),this.worldInfo.AABB=new t(s.added(this.position),i.added(this.position))}updateAABB(){this.AABB.extend(this.shape.AABB)}updateMass(){this.invMass=0===this.mass?0:1/this.mass;const t=this.inertia;t.set(0,0,0);const s=this.invInertia;t.add(this.shape.calculateInertia(this.mass)),s.set(0===t.x?0:1/t.x,0===t.y?0:1/t.y,0===t.z?0:1/t.z),this.inertiaScalar=t.x+t.y+t.z,this.invInertiaScalar=s.x+s.y+s.z}translate(t,s,i){"number"==typeof t?this.position.add(new n(t,s,i).applyQuaternion(this.quaternion)):this.position.add(t.applyQuaternion(this.quaternion))}rotate(t,s,i){if("number"==typeof t){const e=new n(t,s,i),h=e.length();if(0===h)return;this.quaternion.setFromAxisAngle(e.divScalar(h),h)}else{const s=t.length();if(0===s)return;this.quaternion.setFromAxisAngle(t.divScalar(s),s)}}applyImpulse(t,s){this.velocity.add(t.muled(this.invMass))}}const z={getPotentialCollision(t){const s=t.sort(((t,s)=>t.worldInfo.AABB.lowerBound.x<s.worldInfo.AABB.lowerBound.x?-1:t.worldInfo.AABB.lowerBound.x>s.worldInfo.AABB.lowerBound.x?1:0)),i=[];for(let t=0;t<s.length;t++)for(let e=t+1;e<s.length;e++){const n=s[t],h=s[e];if(n.worldInfo.AABB.upperBound.x<h.worldInfo.AABB.lowerBound.x)break;i.push({a:n,b:h})}return i}},w={isColliding(t,s,i,e){const n=t.vertices.map((t=>t.clone().applyQuaternion(i.quaternion).add(i.position))),h=s.vertices.map((t=>t.clone().applyQuaternion(e.quaternion).add(e.position))),r=t.axes.map((t=>t.clone().applyQuaternion(i.quaternion))),o=s.axes.map((t=>t.clone().applyQuaternion(e.quaternion))),a=this.separatingAxis(r,n,h),l=this.separatingAxis(o,h,n);if(null!==a&&null!==l){let t;return t=a.penetration<l.penetration?a:l,{info:new u({normal:t.axis,points:this.findContactPoints(n,h,r,o),penetration:t.penetration})}}return{info:null}},separatingAxis(t,s,i){let e=1/0;const h=new n;for(const n of t){const{min:t,max:r}=this.project(s,n),{min:o,max:a}=this.project(i,n),u=this.calculatePenetrationDepth({min:t,max:r},{min:o,max:a});if(Math.max(t,o)>Math.min(r,a))return null;u<0||u<e&&(e=u,h.copy(n))}return e===1/0?null:{penetration:e,axis:h}},calculatePenetrationDepth:(t,s)=>Math.min(s.max-t.min,t.max-s.min),project(t,s){let i=1/0,e=-1/0;for(const n of t){const t=n.dot(s);t<i&&(i=t),t>e&&(e=t)}return{min:i,max:e}},findContactPoints(t,s,i,e){const n=[],h=this.filterVerticesIntersectingShape(t,s,e);n.push(...h);const r=this.filterVerticesIntersectingShape(s,t,i);return n.push(...r),n},filterVerticesIntersectingShape(t,s,i){let e=t;for(const t of i){const i=[],{min:n,max:h}=this.project(s,t);for(const s of e){const e=s.dot(t);e>n&&e<h&&i.push(s)}e=i}return e},getCenter(t){const s=new n;for(const i of t)s.x+=i.x,s.y+=i.y,s.z+=i.z;return s.x/=t.length,s.y/=t.length,s.z/=t.length,s}};function m(t,s,i,e){function n(s){const e=s.subed(t.position);if(e.lengthSq()<i.radius*i.radius){const s=e.normalized(),n=e.length();return new u({normal:s,points:[s.muledScalar(-i.radius).add(t.position)],penetration:Math.max(n-i.radius,0)})}return null}function h(e){const n=e.normal.clone().applyQuaternion(s.quaternion),h=e.vertices[0].clone().applyQuaternion(s.quaternion).add(s.position),o=Math.abs(h.dot(n)-t.position.dot(n))-i.radius;if(o>0)return null;const a=e.vertices.map((t=>t.clone().applyQuaternion(s.quaternion).add(s.position))),l=t.position.added(n.muledScalar(-i.radius));if(!function(t,s,i){let e=null;for(let n=0;n<t.length;n++){const h=t[n],r=t[(n+1)%t.length].subed(h).crossed(i),o=s.subed(h),a=r.dot(o);if(!(null===e||a>0&&e||a<=0&&!e))return!1;null===e&&(e=a>0)}return!0}(a,t.position,n))for(let t=0;t<a.length;t++){return r(a[t%a.length],a[(t+1)%a.length])}return new u({normal:n.clone(),points:[l],penetration:o})}function r(s,e){const n=e.subed(s),h=t.position.subed(s).dot(n)/n.lengthSq(),r=Math.max(0,Math.min(h,1)),o=s.added(n.muledScalar(r)),a=o.distanceToSq(t.position),l=i.radius-Math.sqrt(a);if(l<0)return null;const c=o.subed(t.position).normalize(),d=t.position.subed(c.muledScalar(i.radius-l));return new u({normal:c.clone(),points:[d],penetration:l})}for(const t of e.vertices){const i=n(t.clone().applyQuaternion(s.quaternion).add(s.position));if(null!==i)return i}for(const t of e.faces){const s=h(t);if(null!==s)return s}return null}class f{constructor({gravity:t=new n}){this.gravity=t,this.bodys=[]}step(t){if(0==t)return;this.bodys.forEach((s=>{s.update(this,t),s.velocity.add(this.gravity.clone().mulScalar(t*s.mass))}));const s=z.getPotentialCollision(this.bodys);for(const t of s)B(t.a,t.b)}add(t){this.bodys.push(t)}}function B(t,s){if(0===t.mass&&0===s.mass)return;const i=t.shape,e=s.shape;let n=null,h=!1;if(i instanceof r&&e instanceof r?n=function(t,s,i,e){return w.isColliding(i,e,t,s).info}(t,s,i,e):i instanceof a&&e instanceof r?n=m(t,s,i,e):i instanceof r&&e instanceof a?(h=!0,n=m(s,t,e,i)):i instanceof a&&e instanceof a&&(n=function(t,s,i,e){if(t.position.distanceToSq(s.position)<(i.radius+e.radius)*(i.radius+e.radius)){const n=i.radius+e.radius-t.position.distanceTo(s.position),h=s.position.clone().sub(t.position).normalize();return new u({points:[t.position.clone().add(h.muledScalar(n))],normal:h,penetration:Math.max(n,0)})}return null}(t,s,i,e)),null!==n){const i=new p("collide");h?l.resolve(s,t,n):l.resolve(t,s,n),i.params.info=n,i.params.body=s,t.dispatchEvent(i),i.params.body=t,s.dispatchEvent(i)}}const g={};class v{constructor({restitution:t=1}){this.restitution=t}}export{t as AABB,x as Body,o as Box,r as ConvexPolygon,h as Face,l as Impulse,g as MATERIALS_RESTITUTION,c as Mat3,v as Material,e as Quaternion,i as Shape,s as ShapeType,a as Sphere,n as Vector3,f as World};
