class t{constructor(t,s){this.lowerBound=t,this.upperBound=s}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const s=this.lowerBound,i=this.upperBound,e=t.lowerBound,n=t.upperBound,r=e.x<=i.x&&i.x<=n.x||s.x<=n.x&&n.x<=i.x,o=e.y<=i.y&&i.y<=n.y||s.y<=n.y&&n.y<=i.y,h=e.z<=i.z&&i.z<=n.z||s.z<=n.z&&n.z<=i.z;return r&&o&&h}contains(t){const s=this.lowerBound,i=this.upperBound,e=t.lowerBound,n=t.upperBound;return s.x<=e.x&&i.x>=n.x&&s.y<=e.y&&i.y>=n.y&&s.z<=e.z&&i.z>=n.z}clone(){return new t(this.lowerBound.clone(),this.upperBound.clone())}}const s={Box:1,Sphere:2,Plane:4,Cylinder:8,ConvexPolygon:16,Trimesh:32};class i{constructor({type:s}){this.type=s,this.parameters={},this.AABB=new t(new n,new n)}updateBoundingSphereRadius(){throw new Error("Not implemented")}updateAABB(){throw new Error("Not implemented")}calculateInertia(t){throw new Error("Not Implemented")}}class e{constructor(t=0,s=0,i=0,e=1){this.isQuaternion=!0,this.x=t,this.y=s,this.z=i,this.w=e}set(t,s,i,e){return this.x=t,this.y=s,this.z=i,this.w=e,this}clone(){return new e(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}setFromAxisAngle(t,s){const i=s/2,e=Math.sin(i);return this.x=t.x*e,this.y=t.y*e,this.z=t.z*e,this.w=Math.cos(i),this}setFromVectors(t,s){let i=t.dot(s)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this.x=-t.y,this.y=t.x,this.z=0,this.w=i):(this.x=0,this.y=-t.z,this.z=t.y,this.w=i)):(this.x=t.y*s.z-t.z*s.y,this.y=t.z*s.x-t.x*s.z,this.z=t.x*s.y-t.y*s.x,this.w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs((s=this.dot(t),i=-1,e=1,Math.max(i,Math.min(e,s)))));var s,i,e}rotateTowards(t,s){const i=this.angleTo(t);if(1===s)return this.copy(t);if(0===i)return this;const e=Math.min(1,s/i);return this.slerp(t,e),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}normalize(){let t=this.length();return 0===t?(this.x=0,this.y=0,this.z=0,this.w=1):(t=1/t,this.x=this.x*t,this.y=this.y*t,this.z=this.z*t,this.w=this.w*t),this}multiply(t){return this.mulQuaternion(t)}mulQuaternion(t){const s=this.x,i=this.y,e=this.z,n=this.w,r=t.x,o=t.y,h=t.z,a=t.w;return this.x=s*a+n*r+i*h-e*o,this.y=i*a+n*o+e*r-s*h,this.z=e*a+n*h+s*o-i*r,this.w=n*a-s*r-i*o-e*h,this.normalize(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const i=this.x,e=this.y,n=this.z,r=this.w;let o=r*t.w+i*t.x+e*t.y+n*t.z;if(o<0?(this.w=-t.w,this.x=-t.x,this.y=-t.y,this.z=-t.z,o=-o):this.copy(t),o>=1)return this.w=r,this.x=i,this.y=e,this.z=n,this;const h=1-o*o;if(h<=Number.EPSILON){const t=1-s;return this._w=t*r+s*this.w,this._x=t*i+s*this.x,this._y=t*e+s*this.y,this._z=t*n+s*this.z,this.normalize(),this}const a=Math.sqrt(h),u=Math.atan2(a,o),l=Math.sin((1-s)*u)/a,c=Math.sin(s*u)/a;return this._w=r*l+this._w*c,this._x=i*l+this._x*c,this._y=e*l+this._y*c,this._z=n*l+this._z*c,this}random(){const t=Math.random(),s=Math.sqrt(1-t),i=Math.sqrt(t),e=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(s*Math.cos(e),i*Math.sin(n),i*Math.cos(n),s*Math.sin(e))}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}class n{constructor(t,s,i){this.isVector=!0,this.x=t??0,this.y=s??0,this.z=i??0}add(t,s,i){return t instanceof Object?(this.x+=t.x,this.y+=t.y,this.z+=t.z):(this.x+=t,this.y+=s??0,this.z+=i??0),this}sub(t,s,i){return t instanceof Object?(this.x-=t.x,this.y-=t.y,this.z-=t.z):(this.x-=t,this.y-=s??0,this.z-=i??0),this}mul(t,s,i){return t instanceof Object?(this.x*=t.x,this.y*=t.y,this.z*=t.z):null==s?(this.x*=t,this.y*=t,this.z*=t):(this.x*=t,this.y*=s??0,this.z*=i??0),this}div(t,s,i){return t instanceof Object?(this.x/=t.x,this.y/=t.y,this.z/=t.z):null==s?(this.x/=t,this.y/=t,this.z/=t):(this.x/=t,this.y/=s??0,this.z/=i??0),this}added(t,s,i){return t instanceof Object?new n(this.x+t.x,this.y+t.y,this.z+t.z):null==s?new n(this.x+t,this.y+t,this.z+t):new n(this.x+t,this.y+(s??0),this.z+(i??0))}subed(t,s,i){return t instanceof Object?new n(this.x-t.x,this.y-t.y,this.z-t.z):null==s?new n(this.x-t,this.y-t,this.z-t):new n(this.x-t,this.y-(s??0),this.z-(i??0))}muled(t,s,i){return t instanceof Object?new n(this.x*t.x,this.y*t.y,this.z*t.z):null==s?new n(this.x*t,this.y*t,this.z*t):new n(this.x*t,this.y*(s??0),this.z*(i??0))}dived(t,s,i){return t instanceof Object?new n(this.x/t.x,this.y/t.y,this.z/t.z):null==s?new n(this.x/t,this.y/t,this.z/t):new n(this.x/t,this.y/(s??0),this.z/(i??0))}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}negated(){return new n(-this.x,-this.y,-this.z)}mulScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}muledScalar(t){return new n(this.x*t,this.y*t,this.z*t)}divScalar(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,s){const i=this.x+(t.x-this.x)*s,e=this.y+(t.y-this.y)*s,r=this.z+(t.z-this.z)*s;return new n(i,e,r)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return this.x=this.y*t.z-this.z*t.y,this.y=this.z*t.x-this.x*t.z,this.z=this.x*t.y-this.y*t.x,this}crossed(t){return new n(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}normalize(t=1){const s=this.length()*t;return this.x/=s,this.y/=s,this.z/=s,this}normalized(t=1){const s=this.length()*t;return new n(this.x/s,this.y/s,this.z/s)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}applyQuaternion(t){const s=this.x,i=this.y,e=this.z,n=t.x,r=t.y,o=t.z,h=t.w,a=2*(r*e-o*i),u=2*(o*s-n*e),l=2*(n*i-r*s);return this.x=s+h*a+r*l-o*u,this.y=i+h*u+o*a-n*l,this.z=e+h*l+n*u-r*a,this}distanceTo(t){return Math.sqrt((t.x-this.x)*(t.x-this.x)+(t.y-this.y)*(t.y-this.y)+(t.z-this.z)*(t.z-this.z))}distanceToSq(t){return(t.x-this.x)*(t.x-this.x)+(t.y-this.y)*(t.y-this.y)+(t.z-this.z)*(t.z-this.z)}toArray(){return[this.x,this.y,this.z]}clone(){return new n(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}set(t,s,i){this.x=t,this.y=s,this.z=i}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}}class r{constructor(t,s){this.vertices=t,this.normal=void 0!==s?s:function(t){const s=new n;for(let i=0;i<t.length;i++){const e=t[i],n=t[(i+1)%t.length];s.add((e.y-n.y)*(e.z+n.z),(e.z-n.z)*(e.x+n.x),(e.z-n.z)*(e.y+n.y))}return s.normalize()}(t)}}class o extends i{constructor({type:t=s.ConvexPolygon,vertices:i,faces:e,axes:n}){super({type:t}),this.type=t,this.vertices=i,this.faces=e,this.axes=n,this.needVerticesUpdate=!1}getFurthestVertex(){let t,s=-1/0;for(const i of this.vertices){const e=i.length();e>s&&(s=e,t=i)}if(void 0===t)throw new Error("This ConvexPolygons does not contain any vertex");return t.clone()}getNearestVertex(){let t,s=1/0;for(const i of this.vertices){const e=i.length();e<s&&(s=e,t=i)}if(void 0===t)throw new Error("This ConvexPolygons does not contain any vertex");return t.clone()}getFurthestVertexInDirection(t){let s,i=-1/0;for(const e of this.vertices){const n=e.dot(t);n>i&&(i=n,s=e)}if(void 0===s)throw new Error("This ConvexPolygon does not contain any vertex");return s.clone()}updateBoundingSphereRadius(){this.boundingSphereRadius=this.getFurthestVertex().length()}updateAABB(){let s=1/0,i=1/0,e=1/0,r=-1/0,o=-1/0,h=-1/0;for(const t of this.vertices)t.x<s?s=t.x:t.x>r&&(r=t.x),t.y<i?i=t.y:t.y>o&&(o=t.y),t.z<e?e=t.z:t.z>h&&(h=t.z);this.AABB=new t(new n(s,i,e),new n(r,o,h))}}class h extends o{constructor(t,i,e){let o,h,a;t instanceof n?(o=t.x,h=t.y,a=t.z):null==i?(o=t,h=t,a=t):(o=t,h=i,a=e??0);const{vertices:u,faces:l,axes:c}=function(t,s,i){const e=[new n(-t,-s,-i),new n(t,-s,-i),new n(t,s,-i),new n(-t,s,-i),new n(-t,-s,i),new n(t,-s,i),new n(t,s,i),new n(-t,s,i)];return{vertices:e,faces:[new r([e[3],e[2],e[1],e[0]],new n(0,0,-1)),new r([e[4],e[5],e[6],e[7]],new n(0,0,1)),new r([e[5],e[4],e[0],e[1]],new n(0,-1,0)),new r([e[2],e[3],e[7],e[6]],new n(0,1,0)),new r([e[0],e[4],e[7],e[3]],new n(-1,0,0)),new r([e[1],e[2],e[6],e[5]],new n(1,0,0))],axes:[new n(0,0,1),new n(0,1,0),new n(1,0,0)]}}(o/2,h/2,a/2);super({type:s.Box,vertices:u,faces:l,axes:c}),this.parameters={width:o,height:h,depth:a},this.updateBoundingSphereRadius(),this.updateAABB()}updateBoundingSphereRadius(){this.boundingSphereRadius=Math.sqrt(this.parameters.width*this.parameters.width+this.parameters.height*this.parameters.height+this.parameters.depth*this.parameters.depth)}updateAABB(){this.AABB=new t(new n(-this.parameters.width/2,-this.parameters.height/2,-this.parameters.depth/2),new n(this.parameters.width/2,this.parameters.height/2,this.parameters.depth/2))}calculateInertia(t){const s=this.parameters.width,i=this.parameters.height,e=this.parameters.depth;return new n(1/(12*t*(2*s*2*i+2*e*2*e)),1/(12*t*(2*s*2*s+2*e*2*e)),1/(12*t*(2*i*2*i+2*s*2*s)))}}class a extends i{constructor(t=0){super({type:s.Sphere}),this.params={radius:t},this.radius=t,this.updateBoundingSphereRadius(),this.updateAABB()}updateAABB(){const s=new n(1,0,0).normalize().mulScalar(this.radius);this.AABB=new t(s.negated(),s)}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateInertia(t){const s=.4*t*this.radius*this.radius;return new n(s,s,s)}}class u{constructor({points:t,normal:s,penetration:i}){this.points=t,this.normal=s,this.penetration=i}}const l={resolve(t,s,i){this.penetrationResolution(t,s,i),this.applyImpulse(t,s,i)},penetrationResolution(t,s,i){const e=i.normal.muledScalar(i.penetration),n=t.mass+s.mass;t.position.add(e.muledScalar(-t.mass/n)),s.position.add(e.muledScalar(s.mass/n))},applyImpulse(t,s,i){const e=[];for(const r of i.points){const o=i.normal,h=r.subed(t.position),a=r.subed(s.position),u=new n(0,0,1),l=h.crossed(u),c=a.crossed(u);0===l.lengthSq()&&l.set(0,0,1),0===c.lengthSq()&&c.set(0,0,1);const d=t.material.restitution*s.material.restitution,p=t.velocity.added(l.muled(t.angularVelocity)).sub(s.velocity.added(c.muled(s.angularVelocity))).dot(o)*-(1+d),y=l.dot(o),x=c.dot(o),m=p/(t.invMass+s.invMass+y*y*t.invInertiaScalar+x*x*s.invInertiaScalar);e.push({impulse:m/i.points.length,normal:o,ra:h,rb:a})}for(const i of e)0!==t.mass&&(t.velocity.add(i.normal.muledScalar(t.invMass*i.impulse)),t.angularVelocity.add(i.ra.crossed(i.normal.muledScalar(i.impulse)).mulScalar(t.invInertiaScalar))),0!==s.mass&&(s.velocity.sub(i.normal.muledScalar(s.invMass*i.impulse)),s.angularVelocity.sub(i.rb.crossed(i.normal.muledScalar(i.impulse)).mulScalar(s.invInertiaScalar)))}};class c{constructor(t=1,s=0,i=0,e=0,n=1,r=0,o=0,h=0,a=1){this.elements=[t,s,i,e,n,r,o,h,a]}get(t,s){return this.elements[3*t+s]}set(t,s,i){this.elements[3*t+s]=i}mul(t){const s=new c;for(let i=0;i<3;i++)for(let e=0;e<3;e++){let n=0;for(let s=0;s<3;s++)n+=this.get(i,s)*t.get(s,e);s.set(i,e,n)}return s}mulScalar(t){const s=new c;for(let i=0;i<9;i++)s.elements[i]=this.elements[i]*t;return s}}class d{addEventListener(t,s){void 0===this.listeners&&(this.listeners=new Map);let i=this.listeners.get(t);void 0===i&&(i=[],this.listeners.set(t,i)),-1===i.indexOf(s)&&i.push(s)}hasEventListener(t,s){if(void 0===this.listeners)return!1;const i=this.listeners.get(t);return void 0!==i&&(-1===i.indexOf(s)&&void 0)}removeEventListener(t,s){if(void 0===this.listeners)return;const i=this.listeners.get(t);if(void 0!==i){const t=i.indexOf(s);-1!==t&&i.splice(t,1)}}dispatchEvent(t){if(void 0===this.listeners)return;const s=this.listeners.get(t.type);if(void 0!==s){t.target=this;const i=s.slice(0);for(let s=0,e=i.length;s<e;s++)i[s].call(this,t);t.target=null}}}class p{constructor(t,s={}){this.type=t,this.params=s,this.target}}const y=0;class x extends d{constructor({shapes:s=[],mass:i=1,material:r=new S({restitution:.1})}){super(),this.shapes=s instanceof Array?s:[s],this.type=y,this.name="UnamedObject",this.material=r,this.position=new n,this.velocity=new n,this.quaternion=new e,this.angularVelocity=new n,this.mass=i,this.invMass,this.inertia=this.shapes[0].calculateInertia(this.mass),this.invInertia=new n,this.inertiaScalar,this.invInertiaScalar,this.updateMass(),this.AABB=new t(new n,new n),0!=this.shapes.length&&this.updateAABB(),this.parrent=null,this.worldInfo={AABB:new t(this.AABB.lowerBound.clone().add(this.position),this.AABB.upperBound.clone().add(this.position))},this.previousInfo={position:this.position.clone(),quaternion:this.quaternion.clone(),mass:i}}update(t,s){if(0!==this.mass&&this.position.add(this.velocity.muledScalar(s)),!this.angularVelocity.isZero()){const t=(new e).setFromAxisAngle(this.angularVelocity.normalized(),this.angularVelocity.length()*s);this.quaternion.mulQuaternion(t)}this.position.equals(this.previousInfo.position)||(this.updateWorldPositionAABB(),this.previousInfo.position.copy(this.position)),this.quaternion.equals(this.previousInfo.quaternion)||(this.updateWorldRotationAABB(),this.previousInfo.quaternion.copy(this.quaternion)),this.mass!=this.previousInfo.mass&&(this.previousInfo.mass=this.mass,this.updateMass())}updateWorldPositionAABB(){this.worldInfo.AABB=new t(this.AABB.lowerBound.added(this.position),this.AABB.upperBound.added(this.position))}updateWorldRotationAABB(){const s=new n(1/0,1/0,1/0),i=new n(-1/0,-1/0,-1/0);for(const t of this.shapes){if(t instanceof o)for(const e of t.vertices){const t=e.clone().applyQuaternion(this.quaternion);t.x<s.x&&(s.x=t.x),t.y<s.y&&(s.y=t.y),t.z<s.z&&(s.z=t.z),t.x>i.x&&(i.x=t.x),t.y>i.y&&(i.y=t.y),t.z>i.z&&(i.z=t.z)}t instanceof a&&(-t.radius<s.x&&(s.x=-t.radius),-t.radius<s.y&&(s.y=-t.radius),-t.radius<s.z&&(s.z=-t.radius),t.radius>i.x&&(i.x=t.radius),t.radius>i.y&&(i.y=t.radius),t.radius>i.z&&(i.z=t.radius))}this.worldInfo.AABB=new t(s.added(this.position),i.added(this.position))}updateAABB(){for(const t of this.shapes)this.AABB.extend(t.AABB)}updateMass(){this.invMass=0==this.mass?0:1/this.mass;const t=this.inertia;this.invInertia.set(t.x>0?1/t.x:0,t.y>0?1/t.y:0,t.z>0?1/t.z:0),this.inertiaScalar=t.x+t.y+t.z,this.invInertiaScalar=0==this.inertiaScalar?0:1/this.inertiaScalar}translate(t,s,i){"number"==typeof t?this.position.add(new n(t,s,i).applyQuaternion(this.quaternion)):this.position.add(t.applyQuaternion(this.quaternion))}rotate(t,s,i){if("number"==typeof t){const e=new n(t,s,i),r=e.length();if(0===r)return;this.quaternion.setFromAxisAngle(e.divScalar(r),r)}else{const s=t.length();if(0===s)return;this.quaternion.setFromAxisAngle(t.divScalar(s),s)}}}const m={getPotentialCollision(t){const s=t.sort(((t,s)=>t.worldInfo.AABB.lowerBound.x<s.worldInfo.AABB.lowerBound.x?-1:t.worldInfo.AABB.lowerBound.x>s.worldInfo.AABB.lowerBound.x?1:0)),i=[];for(let t=0;t<s.length;t++)for(let e=t+1;e<s.length;e++){const n=s[t],r=s[e];if(n.worldInfo.AABB.upperBound.x<r.worldInfo.AABB.lowerBound.x)break;i.push({a:n,b:r})}return i}},z={isColliding(t,s,i,e){const n=t.vertices.map((t=>t.clone().applyQuaternion(i.quaternion).add(i.position))),r=s.vertices.map((t=>t.clone().applyQuaternion(e.quaternion).add(e.position))),o=this.separatingAxis(t,i,n,r),h=this.separatingAxis(s,e,r,n);if(null!==o&&null!==h){let n;return n=o.penetration<h.penetration?o:h,{info:new u({normal:n.axis,points:n===o?this.findContactPoints(t,s,i,e):this.findContactPoints(s,t,e,i),penetration:n.penetration})}}return{info:null}},separatingAxis(t,s,i,e){let r=1/0;const o=new n;for(const n of t.axes){const t=n.clone().applyQuaternion(s.quaternion),{min:h,max:a}=this.project(i,t),{min:u,max:l}=this.project(e,t),c=this.calculatePenetrationDepth({min:h,max:a},{min:u,max:l});if(Math.max(h,u)>Math.min(a,l))return null;c<0||c<r&&(r=c,o.copy(t))}return r===1/0?null:{penetration:r,axis:o}},calculatePenetrationDepth:(t,s)=>Math.min(s.max-t.min,t.max-s.min),project(t,s){let i=1/0,e=-1/0;for(const n of t){const t=n.dot(s);t<i&&(i=t),t>e&&(e=t)}return{min:i,max:e}},findContactPoints(t,s,i,e){const n=[],r=t.vertices.map((t=>t.clone().applyQuaternion(i.quaternion).add(i.position))),o=s.vertices.map((t=>t.clone().applyQuaternion(e.quaternion).add(e.position))),h=this.filterVerticesIntersectingShape(r,s,e);n.push(...h);const a=this.filterVerticesIntersectingShape(o,t,i);return n.push(...a),n},filterVerticesIntersectingShape(t,s,i){let e=t;for(const t of s.axes){const n=[],r=t.applyQuaternion(i.quaternion),{min:o,max:h}=this.project(s.vertices,r);for(const t of e){const s=t.dot(r);s>o&&s<h&&n.push(t)}e=n}return e},getCenter(t){const s=new n;for(const i of t)s.x+=i.x,s.y+=i.y,s.z+=i.z;return s.x/=t.length,s.y/=t.length,s.z/=t.length,s}};class w{constructor({gravity:t=new n}){this.gravity=t,this.bodys=[]}step(t){if(0==t)return;this.bodys.forEach((s=>{s.update(this,t),s.velocity.add(this.gravity.clone().mulScalar(t*s.mass))}));const s=m.getPotentialCollision(this.bodys);for(const t of s)f(t.a,t.b)}add(t){this.bodys.push(t)}}function f(t,s){if(0!==t.mass||0!==s.mass)for(const i of t.shapes)for(const e of s.shapes){let n=null,r=!1;if(i instanceof o&&e instanceof o?n=v(t,s,i,e):i instanceof a&&e instanceof o?n=B(t,s,i,e):i instanceof o&&e instanceof a?(r=!0,n=B(s,t,e,i)):i instanceof a&&e instanceof a&&(n=g(t,s,i,e)),null!==n){const i=new p("collide");r?l.resolve(s,t,n):l.resolve(t,s,n),i.params.info=n,i.params.body=s,t.dispatchEvent(i),i.params.body=t,s.dispatchEvent(i)}}}function B(t,s,i,e){function n(s){const e=s.subed(t.position);if(e.lengthSq()<i.radius*i.radius){const s=e.normalized(),n=e.length();return new u({normal:s,points:[s.muledScalar(-i.radius).add(t.position)],penetration:Math.max(n-i.radius,0)})}return null}function r(e){const n=e.normal.clone().applyQuaternion(s.quaternion),r=e.vertices[0].clone().applyQuaternion(s.quaternion).add(s.position),h=Math.abs(r.dot(n)-t.position.dot(n))-i.radius;if(h>0)return null;const a=e.vertices.map((t=>t.clone().applyQuaternion(s.quaternion).add(s.position))),l=t.position.added(n.muledScalar(-i.radius));if(!function(t,s,i){let e=null;for(let n=0;n<t.length;n++){const r=t[n],o=t[(n+1)%t.length].subed(r).crossed(i),h=s.subed(r),a=o.dot(h);if(!(null===e||a>0&&e||a<=0&&!e))return!1;null===e&&(e=a>0)}return!0}(a,t.position,n))for(let t=0;t<a.length;t++){return o(a[t%a.length],a[(t+1)%a.length])}return new u({normal:n.clone(),points:[l],penetration:h})}function o(s,e){const n=e.subed(s),r=t.position.subed(s).dot(n)/n.lengthSq(),o=Math.max(0,Math.min(r,1)),h=s.added(n.muledScalar(o)),a=h.distanceToSq(t.position),l=i.radius-Math.sqrt(a);if(l<0)return null;const c=h.subed(t.position).normalize(),d=t.position.subed(c.muledScalar(i.radius-l));return new u({normal:c.clone(),points:[d],penetration:l})}for(const t of e.vertices){const i=n(t.clone().applyQuaternion(s.quaternion).add(s.position));if(null!==i)return i}for(const t of e.faces){const s=r(t);if(null!==s)return s}return null}function g(t,s,i,e){if(t.position.distanceToSq(s.position)<(i.radius+e.radius)*(i.radius+e.radius)){const n=i.radius+e.radius-t.position.distanceTo(s.position),r=s.position.clone().sub(t.position).normalize();return new u({points:[t.position.clone().add(r.muledScalar(n))],normal:r,penetration:Math.max(n,0)})}return null}function v(t,s,i,e){return z.isColliding(i,e,t,s).info}const A={};class S{constructor({restitution:t=1}){this.restitution=t}}export{t as AABB,x as Body,h as Box,o as ConvexPolygon,r as Face,l as Impulse,A as MATERIALS_RESTITUTION,c as Mat3,S as Material,e as Quaternion,i as Shape,s as ShapeType,a as Sphere,n as Vector3,w as World};
